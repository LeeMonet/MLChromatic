# -*- coding: utf-8 -*-
"""FasterChromSym

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13YL7oK-bgbe1f5sPgV3OFu4o46Tyb5eB

# Imports and Globally Used Methods
"""

import math
import more_itertools as mit
import scipy.special
import numpy as np 

import math
import scipy.special
from collections import defaultdict
from itertools import product, combinations


def edge_to_index(n,a,b):
  """
  The hard part is g is given as a (n choose 2) binary tuple
  We will need to translate this tuple to edges
  tuples is written in the order (1,2), (1,3), (1,4), ... (2,3), (2,4), ...
  """
  # Mathematica: Sum[n - i, {i, 1, a - 1}] + b - a - 1 // Simplify
  return int(b + a*(n-1/2)-n-(a*a)/2-1)

def net_count(g,n):
  """
  counts the number of induced nets
  graph g as C(n,2)-length array of 0/1 indicators of edges
    (1,2),...,(1,n),(2,3),...,(2,n),...,(n-1,n)
  """
  adjMat = defaultdict(int)
  nbhd = defaultdict(set)

  count = 0 # number of induced nets

  # Data structures: Dictionary adjacency matrix for a<b
  #   Set neighborhood regardless of order
  # Loop through the input 01 string tracking a,b and storing
  idx = 0   # position in input array
  for a in range(1,n+1):
    for b in range(a+1,n+1):
      if(g[idx]==1):
        adjMat[(a,b)] = 1
        nbhd[a] = nbhd[a].union(set([b]))
        nbhd[b] = nbhd[b].union(set([a]))
      idx += 1

  # An induced net has a triangle x<y<z and
  #   a perfect matching from {x,y,z} to {a,b,c}
  #   conditioned on (1) {a,b,c} being an independent set
  #              and (2) No other edges from {x,y,z} to {a,b,c}
  # Counting strategy: Loop over x, then y>x in nbhd[x],
  #   then z>y in nbhd[x]\cap nbhd[y]
  #   Construct A = N(x)-(N(y)\cup N(z)\cup {y,z})
  #             B = N(y)-(N(x)\cup N(z)\cup {x,z})
  #             C = N(z)-(N(x)\cup N(y)\cup {x,y})
  #     (actually we drop the last \cup {*,*}, redundant)
  #   Inner loop over A x B x C: add 1 to count if = I_3

  for x in range(1,n+1):
    for y in [_ for _ in nbhd[x] if _ > x]:
      for z in [_ for _ in nbhd[x].intersection(nbhd[y]) if _ > y]:
        A = nbhd[x] - nbhd[y].union(nbhd[z])
        B = nbhd[y] - nbhd[x].union(nbhd[z])
        C = nbhd[z] - nbhd[x].union(nbhd[y])
        # print((x,y,z),A,B,C,[_ for _ in product(A,B,C)])
        for w in product(A,B,C):
          w = sorted(w)
          # print(w,adjMat[w[0],w[1]], adjMat[w[0],w[2]],adjMat[w[1],w[2]])
          count = count + 1 - max(adjMat[w[0],w[1]], adjMat[w[0],w[2]], adjMat[w[1],w[2]])
  return count

def edges_to_bitlist(edge_tuples, n):
  # Input: list of edge tuples [(i1,j1),(i2,j2),...] and number vertices n
  # Output: The C(n,2)-long 01 bit-list encoding the graph
  bitlist = [0]*int(n*(n-1)/2)
  for edge in edge_tuples:
    edge = sorted(edge)
    bitlist[edge_to_index(n,edge[0],edge[1])] = 1
  return bitlist

def integer_partitions(n):
  """"""
  hold = []
  p = [0] * n  # An array to store a partition
  k = 0    # Index of last element in a partition
  p[k] = n   # Initialize first partition
        # as number itself

  # This loop first prints current partition,
  # then generates next partition.The loop
  # stops when the current partition has all 1s
  while True:
    
      # print current partition
      temp = []
      for i in range(0,k+1):
        temp.append(p[i])
      yield temp
      hold.append(temp)

      # Generate next partition

      # Find the rightmost non-one value in p[].
      # Also, update the rem_val so that we know
      # how much value can be accommodated
      rem_val = 0
      while k >= 0 and p[k] == 1:
        rem_val += p[k]
        k -= 1

      # if k < 0, all the values are 1 so
      # there are no more partitions
      if k < 0:
        return

      # Decrease the p[k] found above
      # and adjust the rem_val
      p[k] -= 1
      rem_val += 1

      # If rem_val is more, then the sorted
      # order is violated. Divide rem_val in
      # different values of size p[k] and copy
      # these values at different positions after p[k]
      while rem_val > p[k]:
        p[k + 1] = p[k]
        rem_val = rem_val - p[k]
        k += 1

      # Copy rem_val to next position
      # and increment position
      p[k + 1] = rem_val
      k += 1

"""# Reward Function Methods"""
def min_nonzero(F):
  """
  Given a list of integers, return the smallest nonzero entry
  """
  #look for first non-zero
  i = 0
  while(int(F[i])==0 and i<len(F)):
    i+=1
  if i+1==len(F):
    return 0
  #now look for smallest
  c = int(F[i+1])
  for j in range(i+2,len(F)):
    if not int(F[j])==0:
      if int(F[j])<c:
        c = int(F[j])
  return c
  
#These methods will take operate on a graph g written as a bitstring of edges.
def number_of_vertices(g):
  a = len(g)
  a = 2*a
  return int(math.sqrt(a)+1)

def index_to_edge(n,i):
  """
  The hard part is g is given as a (n choose 2) binary tuple
  We will need to translate this tuple to edges
  tuples is written in the order (1,2), (1,3), (1,4), ... (2,3), (2,4), ...
  """
  afound = False
  a = 1
  b = 0
  s = n-a
  while(afound == False):
    if not i<s:
      a += 1
      s += n-a
    else:
      #print("a was found to be", a)
      afound = True
      b = i-s+1+n#s-i+n+1
  return [a,b]


def g_has_edge(g,n,a,b):
  """
  Will return true if there is an edge a to b.
  """
  #print("checking edge at index", edge_to_index(n,a,b))
  if g[edge_to_index(n,a,b)]==1:
    return True
  return False


def claw_count(g,n):
  """
  counts the number of induced claws
  """
  count = 0
  for a in range(1,n+1):
    for b in range(a+1,n+1):
      for c in range(b+1,n+1):
        for d in range(c+1,n+1):
          ab = g_has_edge(g,n,a,b)
          ac = g_has_edge(g,n,a,c)
          ad = g_has_edge(g,n,a,d)
          bc = g_has_edge(g,n,b,c)
          bd = g_has_edge(g,n,b,d)
          cd = g_has_edge(g,n,c,d)
          deg = [ab+ac+ad,ab+bc+bd,ac+bc+cd,ad+bd+cd]
          #print(deg)
          deg.sort()
          if deg == [1,1,1,3]:
            count += 1
  return count

def connected_component(g,n,v):
  """
  Given a graph g on n vertices, we return the collection
  of vertices connected to v in g.
  """
  vertices = []
  done = False
  new_found = [v]
  while(len(new_found)>0 ):
    to_search = new_found
    vertices += new_found
    new_found = []
    found = []
    #print("to search", to_search)
    #print("new_found before search", new_found)
    for w in to_search:
      #print("looking at", w)
      for b in range(1,n+1):
        if not w==b:
          i = 0
          if w<b:
            i =  edge_to_index(n,w,b)
          if w>b:
            i =  edge_to_index(n,b,w)
          if g[i]==1:
            found += [b]
            #print("found", b)
    for f in found:
      if (not (f in vertices)) and (not (f in new_found)):
        new_found += [f]
        #print(f, "is new")
  return vertices
def is_connected_minus_triple(g,n,a,b,c):
  """
  Given a graph g on n vertices (g given as a binary list of edges)
  We return true if g minus the vertices a, b and c is connected.
  """
  #remove edges connected to a, b and c
  #print("we are removing", a, b, c)
  h = []
  NN = len(g)
  for i in range(NN):
    #print("index", i)
    edge = index_to_edge(n,i)
    #print("looking at edge", edge)
    x,y = edge[0],edge[1]
    if (x in [a,b,c]) or (y in [a,b,c]):
      h += [0]
    else:
      h += [g[i]]
  v = 1
  found = False
  while(found == False):
    if v in [a,b,c]:
      v+= 1
    else:
      found = True
  #print("graph with removal", h)
  #print("looking at connected component of", v)
  #print("this compoent is", connected_component(h,n,v))
  if len(connected_component(h,n,v)) == n-3:
    return True
  return False
def count_claw_contractions(g,n):
  """
  Counts the numbers of triples a,b,c (without order) whose removal
  leaves the graph connected. i.e. we contract to the claw.
  """
  count = 0
  for a in range(1,n+1):
    for b in range(a+1,n+1):
      for c in range(b+1,n+1):
        #print("a,b,c:", a,b,c)
        if not (g_has_edge(g,n,a,b) or g_has_edge(g,n,a,c) or g_has_edge(g,n,b,c)):
          #print("good triple to look at")
          if is_connected_minus_triple(g,n,a,b,c):
            #print("was connected")
            count += 1
  return count
"""# Monomial Expansion"""

def is_stable(g,n,B):
  """
  Given a graph g and set partition B we will return false if there 
  is an edge between an i and j in a single block of B
  and true if g restricted to each block of B is an independent set.
  """
  #print(B, "stable check")
  for block in B:
    m = len(block)
    for a in range(m):
      for b in range(a+1,m):
        #print(block[a],block[b],"edge check")
        if g_has_edge(g,n,block[a],block[b]):
          #print("yes edge")
          return False
        #print("no edge")
  return True

def set_partition_to_type(B):
  """
  Given a set partition like [[1,3],[2,4,5]]
  we return the associated integer partition determined by the sizes of the blocks
  we will return [3,2]
  """
  mu = [len(A) for A in B]
  mu.sort(reverse=True)
  return mu

def parts_factorial(pi):
  """
  Given an integer partitions that has r_i parts of size i
  we return the product of r_i factorial
  """
  r = 1
  c = 1
  for i in range(1,len(pi)):
    if pi[i-1]==pi[i]:
      c += 1
      r = r*c
    else:
      c = 1
  return r

def partition_to_index(pi,n):
  """
  Takes an integer partition pi of n and returns the index of 
  pi in the list of integer partitions of n with us never having
  to store the integer partitions. 
  """
  i = 0
  for mu in integer_partitions(n):
    if pi == mu:
      return i
    i += 1
  return -1

def number_of_integer_partitions(n):
  """
  Since we are never storing the number of integer partitions
  we need a method to return the count since there is no nice
  closed form. 
  """
  c = 0
  for mu in integer_partitions(n):
    c+=1
  return c

def X_monomial(g,n):
  """
  Given a graph g we return the chromatic symmetric function as a 
  dictionary of coefficients in the monomial basis.
  """
  C = [0 for i in range(number_of_integer_partitions(n))]
  #print("coeff at start", C)
  for A in mit.set_partitions([i for i in range(1,n+1)]):
    if is_stable(g,n,A):
      #print("checking out set partition", A)
      #print("index of", A, " is", partition_to_index(set_partition_to_type(A),n))
      C[partition_to_index(set_partition_to_type(A),n)] += 1
  i = 0
  for pi in integer_partitions(n):
    C[i] = C[i]*parts_factorial(pi)
    i += 1
  return C

"""# To Elementary"""

def X_elementary(g,n, TRANSITION):
  """
  Given a graph g on n vertices we return its expansion in the 
  elementary basis as a matrix.
  """
  f = X_monomial(g,n)
  t = np.transpose(np.matrix(f))
  f_e = TRANSITION*t
  return f_e

def X_as_string(basis, f, n):
  """
  Will give you a pretty string of f as its expansion is basis basis.
  For example if you have the monomial basis set basis as 'm'
  and for the elementary set basis as 'e'.
  """
  i = 0
  f_string = ""
  first_term = True
  for mu in integer_partitions(n):
    if not f[i]==0:
      if first_term == True:
        f_string += str(int(f[i]))+"*"+basis+str(mu)
        first_term = False
      else:
        if f[i]>0:
          f_string += "+"
        f_string += (str(int(f[i]))+"*"+basis+str(mu))
    i+=1
  return f_string