# -*- coding: utf-8 -*-
"""FasterChromSym

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13YL7oK-bgbe1f5sPgV3OFu4o46Tyb5eB

# Imports and Globally Used Methods
"""

import math
import more_itertools as mit
import scipy.special
import numpy as np 


def integer_partitions(n):
  """"""
  hold = []
  p = [0] * n  # An array to store a partition
  k = 0    # Index of last element in a partition
  p[k] = n   # Initialize first partition
        # as number itself

  # This loop first prints current partition,
  # then generates next partition.The loop
  # stops when the current partition has all 1s
  while True:
    
      # print current partition
      temp = []
      for i in range(0,k+1):
        temp.append(p[i])
      yield temp
      hold.append(temp)

      # Generate next partition

      # Find the rightmost non-one value in p[].
      # Also, update the rem_val so that we know
      # how much value can be accommodated
      rem_val = 0
      while k >= 0 and p[k] == 1:
        rem_val += p[k]
        k -= 1

      # if k < 0, all the values are 1 so
      # there are no more partitions
      if k < 0:
        return

      # Decrease the p[k] found above
      # and adjust the rem_val
      p[k] -= 1
      rem_val += 1

      # If rem_val is more, then the sorted
      # order is violated. Divide rem_val in
      # different values of size p[k] and copy
      # these values at different positions after p[k]
      while rem_val > p[k]:
        p[k + 1] = p[k]
        rem_val = rem_val - p[k]
        k += 1

      # Copy rem_val to next position
      # and increment position
      p[k + 1] = rem_val
      k += 1

"""# Reward Function Methods"""

def min_nonzero(F):
  """
  Given a list of integers, return the smallest nonzero entry
  """
  #look for first non-zero
  i = 0
  while(int(F[i])==0 and i<len(F)):
    i+=1
  if i+1==len(F):
    return 0
  #now look for smallest
  c = int(F[i+1])
  for j in range(i+2,len(F)):
    if not int(F[j])==0:
      if int(F[j])<c:
        c = int(F[j])
  return c

#These methods will take operate on a graph g written as a bitstring of edges.
def number_of_vertices(g):
  a = len(g)
  a = 2*a
  return int(math.sqrt(a)+1)

def edge_to_index(n,a,b):
  """
  The hard part is g is given as a (n choose 2) binary tuple
  We will need to translate this tuple to edges
  tuples is written in the order (1,2), (1,3), (1,4), ... (2,3), (2,4), ...
  """
  if a==1:
    return b-2
  s = 0
  for i in range(1,a):
    s += n-i
  return s+b-a-1

def index_to_edge(n,i):
  """
  The hard part is g is given as a (n choose 2) binary tuple
  We will need to translate this tuple to edges
  tuples is written in the order (1,2), (1,3), (1,4), ... (2,3), (2,4), ...
  """
  afound = False
  a = 1
  b = 0
  s = n-a
  while(afound == False):
    if not i<s:
      a += 1
      s += n-a
    else:
      afound = True
      b = s-i+n+1
  return [a,b]

def g_has_edge(g,n,a,b):
  """
  Will return true if there is an edge a to b.
  """
  #print("checking edge at index", edge_to_index(n,a,b))
  if g[edge_to_index(n,a,b)]==1:
    return True
  return False

def claw_count(g,n):
  """
  counts the number of induced claws
  """
  count = 0
  for a in range(1,n+1):
    for b in range(a+1,n+1):
      for c in range(b+1,n+1):
        for d in range(c+1,n+1):
          ab = g_has_edge(g,n,a,b)
          ac = g_has_edge(g,n,a,c)
          ad = g_has_edge(g,n,a,d)
          bc = g_has_edge(g,n,b,c)
          bd = g_has_edge(g,n,b,d)
          cd = g_has_edge(g,n,c,d)
          deg = [ab+ac+ad,ab+bc+bd,ac+bc+cd,ad+bd+cd]
          #print(deg)
          deg.sort()
          if deg == [1,1,1,3]:
            count += 1
  return count

def is_connected(g,n,a,b,c):
  """
  Given a graph g on n vertices (g given as a binary list of edges)
  We return true if g minus the vertices a, b and c is connected.
  """
  #remove edges connected to a, b and c
  h = []
  NN = len(g)
  for i in range(NN):
    edge = index_to_edge(i)
    x,y = edge[0],edge[1]
    if (x in [a,b,c]) or (y in [a,b,c]):
      h += [0]
    else:
      h += g[i]
  alpha = partition_g(h)
  if alpha == [n-3,1,1,1]:
    return True
  return False


def count_claw_contractions(g,n):
  """
  Counts the numbers of triples a,b,c (without order) whose removal
  leaves the graph connected. i.e. we contract to the claw.
  """
  count = 0
  for a in range(1,n+1):
    for b in range(a+1,n+1):
      for c in range(b+1,n+1):
        if not (g_has_edge(n,a,b) or g_has_edge(n,a,c) or g_has_edge(n,b,c)):
          if is_connected(g,n,a,b,c):
            count += 1
  return count

"""# Graph Methods"""

#These methods will take operate on a graph g written as a bitstring of edges.
def number_of_vertices(g):
  a = len(g)
  a = 2*a
  return int(math.sqrt(a)+1)

def edge_to_index(n,a,b):
  """
  The hard part is g is given as a (n choose 2) binary tuple
  We will need to translate this tuple to edges
  tuples is written in the order (1,2), (1,3), (1,4), ... (2,3), (2,4), ...
  """
  if a==1:
    return b-2
  s = 0
  for i in range(1,a):
    s += n-i
  return s+b-a-1

def index_to_edge(n,i):
  """
  The hard part is g is given as a (n choose 2) binary tuple
  We will need to translate this tuple to edges
  tuples is written in the order (1,2), (1,3), (1,4), ... (2,3), (2,4), ...
  """
  afound = False
  a = 1
  b = 0
  s = n-a
  while(afound == False):
    if not i<s:
      a += 1
      s += n-a
    else:
      afound = True
      b = s-i+n+1
  return [a,b]

def g_has_edge(g,n,a,b):
  """
  Will return true if there is an edge a to b.
  """
  #print("checking edge at index", edge_to_index(n,a,b))
  if g[edge_to_index(n,a,b)]==1:
    return True
  return False

"""# Monomial Expansion"""

def is_stable(g,n,B):
  """
  Given a graph g and set partition B we will return false if there 
  is an edge between an i and j in a single block of B
  and true if g restricted to each block of B is an independent set.
  """
  #print(B, "stable check")
  for block in B:
    m = len(block)
    for a in range(m):
      for b in range(a+1,m):
        #print(block[a],block[b],"edge check")
        if g_has_edge(g,n,block[a],block[b]):
          #print("yes edge")
          return False
        #print("no edge")
  return True

def set_partition_to_type(B):
  """
  Given a set partition like [[1,3],[2,4,5]]
  we return the associated integer partition determined by the sizes of the blocks
  we will return [3,2]
  """
  mu = [len(A) for A in B]
  mu.sort(reverse=True)
  return mu

def parts_factorial(pi):
  """
  Given an integer partitions that has r_i parts of size i
  we return the product of r_i factorial
  """
  r = 1
  c = 1
  for i in range(1,len(pi)):
    if pi[i-1]==pi[i]:
      c += 1
      r = r*c
    else:
      c = 1
  return r

def partition_to_index(pi,n):
  """
  Takes an integer partition pi of n and returns the index of 
  pi in the list of integer partitions of n with us never having
  to store the integer partitions. 
  """
  i = 0
  for mu in integer_partitions(n):
    if pi == mu:
      return i
    i += 1
  return -1

def number_of_integer_partitions(n):
  """
  Since we are never storing the number of integer partitions
  we need a method to return the count since there is no nice
  closed form. 
  """
  c = 0
  for mu in integer_partitions(n):
    c+=1
  return c

def X_monomial(g,n):
  """
  Given a graph g we return the chromatic symmetric function as a 
  dictionary of coefficients in the monomial basis.
  """
  C = [0 for i in range(number_of_integer_partitions(n))]
  #print("coeff at start", C)
  for A in mit.set_partitions([i for i in range(1,n+1)]):
    if is_stable(g,n,A):
      #print("checking out set partition", A)
      #print("index of", A, " is", partition_to_index(set_partition_to_type(A),n))
      C[partition_to_index(set_partition_to_type(A),n)] += 1
  i = 0
  for pi in integer_partitions(n):
    C[i] = C[i]*parts_factorial(pi)
    i += 1
  return C

"""# To Elementary"""

def X_elementary(g,n, TRANSITION):
  """
  Given a graph g on n vertices we return its expansion in the 
  elementary basis as a matrix.
  """
  f = X_monomial(g,n)
  t = np.transpose(np.matrix(f))
  f_e = TRANSITION*t
  return f_e

def X_as_string(basis, f, n):
  """
  Will give you a pretty string of f as its expansion is basis basis.
  For example if you have the monomial basis set basis as 'm'
  and for the elementary set basis as 'e'.
  """
  i = 0
  f_string = ""
  first_term = True
  for mu in integer_partitions(n):
    if not f[i]==0:
      if first_term == True:
        f_string += str(int(f[i]))+"*"+basis+str(mu)
        first_term = False
      else:
        if f[i]>0:
          f_string += "+"
        f_string += (str(int(f[i]))+"*"+basis+str(mu))
    i+=1
  return f_string